# <!-- Powered by BMAD™ Core -->
template:
  id: architecture-template-v2
  name: 架构文档
  version: 2.0
  output:
    format: markdown
    filename: docs/architecture.md
    title: "{{project_name}} 架构文档"

workflow:
  mode: interactive
  elicitation: advanced-elicitation

sections:
  - id: introduction
    title: 引言
    instruction: |
      如有可用，请在开始前审阅相关文档以获取完整上下文；若至少无法找到 docs/prd.md，请询问用户将以哪些文档作为本架构的依据。
    sections:
      - id: intro-content
        content: |
          本文档概述了 {{project_name}} 的整体项目架构，包含后端系统、共享服务以及非 UI 的相关关注点。其主要目标是为 AI 驱动的开发提供指导性的架构蓝图，确保在所选模式与技术上的一致性与遵循。

          **与前端架构的关系：**
          若项目包含重要的用户界面，将另行提供《前端架构文档》详细说明前端特定的设计，并且必须与本文件配套使用。此处记录的核心技术栈选择（见“技术栈”）对整个项目具有约束力，包括任何前端组件。
      - id: starter-template
        title: 起始模板或既有项目
        instruction: |
          Before proceeding further with architecture design, check if the project is based on a starter template or existing codebase:

          1. Review the PRD and brainstorming brief for any mentions of:
          - Starter templates (e.g., Create React App, Next.js, Vue CLI, Angular CLI, etc.)
          - Existing projects or codebases being used as a foundation
          - Boilerplate projects or scaffolding tools
          - Previous projects to be cloned or adapted

          2. If a starter template or existing project is mentioned:
          - Ask the user to provide access via one of these methods:
            - Link to the starter template documentation
            - Upload/attach the project files (for small projects)
            - Share a link to the project repository (GitHub, GitLab, etc.)
          - Analyze the starter/existing project to understand:
            - Pre-configured technology stack and versions
            - Project structure and organization patterns
            - Built-in scripts and tooling
            - Existing architectural patterns and conventions
            - Any limitations or constraints imposed by the starter
          - Use this analysis to inform and align your architecture decisions

          3. If no starter template is mentioned but this is a greenfield project:
          - Suggest appropriate starter templates based on the tech stack preferences
          - Explain the benefits (faster setup, best practices, community support)
          - Let the user decide whether to use one

          4. If the user confirms no starter template will be used:
          - Proceed with architecture design from scratch
          - Note that manual setup will be required for all tooling and configuration

          Document the decision here before proceeding with the architecture design. If none, just say N/A
        elicit: true
      - id: changelog
        title: 变更记录
        type: table
        columns: [日期, 版本, 描述, 作者]
        instruction: 记录文档版本与变更

  - id: high-level-architecture
    title: 高层架构
    instruction: |
      本节包含多组子章节，用于奠定整体架构的基础。请一次性呈现所有子章节以便整体审阅。
    elicit: true
    sections:
      - id: technical-summary
        title: 技术概述
        instruction: |
          用一段简短文字（3–5 句）概述：
          - 系统的整体架构风格
          - 关键组件及其关系
          - 主要技术选择
          - 正在采用的核心架构模式
          - 与 PRD 目标的对应关系以及本架构如何支撑这些目标
      - id: high-level-overview
        title: 高层概览
        instruction: |
          基于 PRD 的“技术假设”部分，说明：

          1. 主要的架构风格（如 Monolith、Microservices、Serverless、Event-Driven）
          2. PRD 中的仓库结构决策（Monorepo/Polyrepo）
          3. PRD 中的服务架构决策
          4. 概念层面的主要用户交互流或数据流
          5. 关键架构决策及其理由
      - id: project-diagram
        title: 高层项目图
        type: mermaid
        mermaid_type: graph
        instruction: |
          使用 Mermaid 绘制高层架构图，建议包含：
          - 系统边界
          - 主要组件/服务
          - 数据流向
          - 外部集成
          - 用户入口

      - id: architectural-patterns
        title: 架构与设计模式
        instruction: |
          列出将指导本架构的关键高层模式。对每个模式：

          1. 如有多个可选方案，展示 2–3 个可行选项
          2. 给出你的推荐方案及清晰理由
          3. 在最终确定前获取用户确认
          4. 确保与 PRD 的技术假设与项目目标一致

          可考虑的常见模式：
          - 架构风格模式（Serverless、事件驱动、微服务、CQRS、六边形架构）
          - 代码组织模式（依赖注入、仓储、模块、工厂）
          - 数据模式（事件溯源、Saga、服务独立数据库）
          - 通信模式（REST、GraphQL、消息队列、发布/订阅）
        template: "- **{{pattern_name}}:** {{pattern_description}} - _Rationale:_ {{rationale}}"
        examples:
          - "**Serverless Architecture:** Using AWS Lambda for compute - _Rationale:_ Aligns with PRD requirement for cost optimization and automatic scaling"
          - "**Repository Pattern:** Abstract data access logic - _Rationale:_ Enables testing and future database migration flexibility"
          - "**Event-Driven Communication:** Using SNS/SQS for service decoupling - _Rationale:_ Supports async processing and system resilience"

  - id: tech-stack
    title: 技术栈
    instruction: |
      本节是技术选择的“单一事实来源”。与你的用户一起做出具体选择：

      1. 回顾 PRD 的技术假设，以及 {root}/data/technical-preferences.yaml 或附带的技术偏好文件
      2. 各类别提供 2–3 个可行选项，附上优缺点
      3. 基于项目需求给出清晰推荐
      4. 对每项选择获得用户的明确确认
      5. 记录精确版本（避免使用 latest，应锁定具体版本）
      6. 表格作为唯一权威来源，其它文档必须引用此处的选择

      在展示表格前，请先确认或询问以下关键决策（若用户拿不准，请给出带理由的建议）：

      - 起始模板（如有）
      - 语言与运行时（含精确版本）
      - 框架与依赖包
      - 云厂商与核心服务
      - 数据库与存储方案（不明确时，可结合项目与云厂商给出 SQL/NoSQL 等建议）
      - 开发工具

      渲染表格后，强调该部分选择的重要性，检查是否有遗漏或分歧，对不明确的条目及时澄清，并立即收集反馈，然后再允许输入。
    elicit: true
    sections:
      - id: cloud-infrastructure
        title: 云基础设施
        template: |
          - **Provider:** {{cloud_provider}}
          - **Key Services:** {{core_services_list}}
          - **Deployment Regions:** {{regions}}
      - id: technology-stack-table
        title: 技术栈表
        type: table
        columns: [类别, 技术, 版本, 目的, 理由]
        instruction: Populate the technology stack table with all relevant technologies
        examples:
          - "| **Language** | TypeScript | 5.3.3 | Primary development language | Strong typing, excellent tooling, team expertise |"
          - "| **Runtime** | Node.js | 20.11.0 | JavaScript runtime | LTS version, stable performance, wide ecosystem |"
          - "| **Framework** | NestJS | 10.3.2 | Backend framework | Enterprise-ready, good DI, matches team patterns |"

  - id: data-models
    title: 数据模型
    instruction: |
      定义核心数据模型/实体：

      1. 回顾 PRD 要求并识别关键业务实体
      2. 对每个模型说明其目的与关系
      3. 列出关键属性及其数据类型
      4. 展示模型间的关系
      5. 与用户讨论设计决策

      在进入数据库模式设计前，先形成清晰的概念模型。
    elicit: true
    repeatable: true
    sections:
      - id: model
        title: "{{model_name}}"
        template: |
          **Purpose:** {{model_purpose}}

          **Key Attributes:**
          - {{attribute_1}}: {{type_1}} - {{description_1}}
          - {{attribute_2}}: {{type_2}} - {{description_2}}

          **Relationships:**
          - {{relationship_1}}
          - {{relationship_2}}

  - id: components
    title: 组件
    instruction: |
      结合上文中的架构模式、技术栈与数据模型：

      1. 识别主要逻辑组件/服务及其职责
      2. 考虑 PRD 中的仓库结构（monorepo/polyrepo）
      3. 定义组件之间清晰的边界与接口
      4. 对每个组件，明确：
      - 主要职责
      - 暴露的关键接口/API
      - 对其他组件的依赖
      - 基于技术栈选择的技术细节

      5. 需要时绘制组件图
    elicit: true
    sections:
      - id: component-list
        repeatable: true
        title: "{{component_name}}"
        template: |
          **Responsibility:** {{component_description}}

          **Key Interfaces:**
          - {{interface_1}}
          - {{interface_2}}

          **Dependencies:** {{dependencies}}

          **Technology Stack:** {{component_tech_details}}
      - id: component-diagrams
        title: 组件图
        type: mermaid
        instruction: |
          使用 Mermaid 可视化组件关系，可选：
          - C4 容器图（高层视角）
          - 组件图（内部结构细节）
          - 时序图（复杂交互）
          选择最有利于表达清晰度的图式

  - id: external-apis
    title: 外部 API
    condition: Project requires external API integrations
    instruction: |
      针对每个外部服务集成：

      1. 基于 PRD 要求与组件设计识别所需 API
      2. 若文档链接未知，请向用户询问
      3. 记录认证方式与安全考虑
      4. 列出将使用的具体端点
      5. 说明任何速率限制或使用约束

      若无需外部 API，请明确说明并跳过本节。
    elicit: true
    repeatable: true
    sections:
      - id: api
        title: "{{api_name}} 接口"
        template: |
          - **Purpose:** {{api_purpose}}
          - **Documentation:** {{api_docs_url}}
          - **Base URL(s):** {{api_base_url}}
          - **Authentication:** {{auth_method}}
          - **Rate Limits:** {{rate_limits}}

          **Key Endpoints Used:**
          - `{{method}} {{endpoint_path}}` - {{endpoint_purpose}}

          **Integration Notes:** {{integration_considerations}}

  - id: core-workflows
    title: 核心工作流
    type: mermaid
    mermaid_type: sequence
    instruction: |
      使用时序图展现关键系统工作流：

      1. 从 PRD 中识别关键用户路径
      2. 展示组件交互（含外部 API）
      3. 纳入错误处理路径
      4. 记录异步操作
      5. 视情况提供高层与细化两种图

      优先选择能澄清架构决策或复杂交互的工作流。
    elicit: true

  - id: rest-api-spec
    title: REST API 规范
    condition: Project includes REST API
    type: code
    language: yaml
    instruction: |
      If the project includes a REST API:

      1. Create an OpenAPI 3.0 specification
      2. Include all endpoints from epics/stories
      3. Define request/response schemas based on data models
      4. Document authentication requirements
      5. Include example requests/responses

      Use YAML format for better readability. If no REST API, skip this section.
    elicit: true
    template: |
      openapi: 3.0.0
      info:
        title: {{api_title}}
        version: {{api_version}}
        description: {{api_description}}
      servers:
        - url: {{server_url}}
          description: {{server_description}}

  - id: database-schema
    title: 数据库模式
    instruction: |
      将概念层数据模型转化为具体的数据库模式：

      1. 使用“技术栈”中选定的数据库类型
      2. 使用合适的记法创建模式定义
      3. 包含索引、约束与关系
      4. 考虑性能与可扩展性
      5. 对于 NoSQL，展示文档结构

      使用适合相应数据库类型的格式呈现模式（SQL DDL、JSON Schema 等）。
    elicit: true

  - id: source-tree
    title: 源码树
    type: code
    language: plaintext
    instruction: |
      创建能体现以下要点的项目目录结构：

      1. 选定的仓库结构（monorepo/polyrepo）
      2. 服务架构（单体/微服务/无服务器）
      3. 选择的技术栈与语言
      4. 上文的组件组织方式
      5. 所选框架的最佳实践
      6. 清晰的关注点分离

      结合项目需要进行调整：monorepo 展示服务拆分；serverless 展示函数组织；并包含与语言相关的约定。
    elicit: true
    examples:
      - |
        project-root/
        ├── packages/
        │   ├── api/                    # Backend API service
        │   ├── web/                    # Frontend application
        │   ├── shared/                 # Shared utilities/types
        │   └── infrastructure/         # IaC definitions
        ├── scripts/                    # Monorepo management scripts
        └── package.json                # Root package.json with workspaces

  - id: infrastructure-deployment
    title: 基础设施与部署
    instruction: |
      定义部署架构与实践：

      1. 使用“技术栈”中选定的 IaC 工具
      2. 选择与架构匹配的部署策略
      3. 定义环境与晋升流程
      4. 设定回滚机制
      5. 考虑安全、监控与成本优化

      征询用户对部署偏好与 CI/CD 工具的选择。
    elicit: true
    sections:
      - id: infrastructure-as-code
        title: 基础设施即代码
        template: |
          - **Tool:** {{iac_tool}} {{version}}
          - **Location:** `{{iac_directory}}`
          - **Approach:** {{iac_approach}}
      - id: deployment-strategy
        title: 部署策略
        template: |
          - **Strategy:** {{deployment_strategy}}
          - **CI/CD Platform:** {{cicd_platform}}
          - **Pipeline Configuration:** `{{pipeline_config_location}}`
      - id: environments
        title: 环境
        repeatable: true
        template: "- **{{env_name}}:** {{env_purpose}} - {{env_details}}"
      - id: promotion-flow
        title: Environment Promotion Flow
        type: code
        language: text
        template: "{{promotion_flow_diagram}}"
      - id: rollback-strategy
        title: Rollback Strategy
        template: |
          - **Primary Method:** {{rollback_method}}
          - **Trigger Conditions:** {{rollback_triggers}}
          - **Recovery Time Objective:** {{rto}}

  - id: error-handling-strategy
    title: 错误处理策略
    instruction: |
      定义全面的错误处理方案：

      1. 结合“技术栈”选择与语言/框架匹配的模式
      2. 设定日志标准与工具
      3. 建立错误分类与处理规则
      4. 考虑可观测性与调试需求
      5. 确保安全（日志中不得包含敏感数据）

      本节用于指导 AI 与人类开发者一致地进行错误处理。
    elicit: true
    sections:
      - id: general-approach
        title: 总体方法
        template: |
          - **Error Model:** {{error_model}}
          - **Exception Hierarchy:** {{exception_structure}}
          - **Error Propagation:** {{propagation_rules}}
      - id: logging-standards
        title: 日志标准
        template: |
          - **Library:** {{logging_library}} {{version}}
          - **Format:** {{log_format}}
          - **Levels:** {{log_levels_definition}}
          - **Required Context:**
            - Correlation ID: {{correlation_id_format}}
            - Service Context: {{service_context}}
            - User Context: {{user_context_rules}}
      - id: error-patterns
        title: 错误处理模式
        sections:
          - id: external-api-errors
            title: External API Errors
            template: |
              - **Retry Policy:** {{retry_strategy}}
              - **Circuit Breaker:** {{circuit_breaker_config}}
              - **Timeout Configuration:** {{timeout_settings}}
              - **Error Translation:** {{error_mapping_rules}}
          - id: business-logic-errors
            title: 业务逻辑错误
            template: |
              - **Custom Exceptions:** {{business_exception_types}}
              - **User-Facing Errors:** {{user_error_format}}
              - **Error Codes:** {{error_code_system}}
          - id: data-consistency
            title: 数据一致性
            template: |
              - **Transaction Strategy:** {{transaction_approach}}
              - **Compensation Logic:** {{compensation_patterns}}
              - **Idempotency:** {{idempotency_approach}}

  - id: coding-standards
    title: 编码规范
    instruction: |
      These standards are MANDATORY for AI agents. Work with user to define ONLY the critical rules needed to prevent bad code. Explain that:

      1. This section directly controls AI developer behavior
      2. Keep it minimal - assume AI knows general best practices
      3. Focus on project-specific conventions and gotchas
      4. Overly detailed standards bloat context and slow development
      5. Standards will be extracted to separate file for dev agent use

      For each standard, get explicit user confirmation it's necessary.
    elicit: true
    sections:
      - id: core-standards
        title: 核心规范
        template: |
          - **Languages & Runtimes:** {{languages_and_versions}}
          - **Style & Linting:** {{linter_config}}
          - **Test Organization:** {{test_file_convention}}
      - id: naming-conventions
        title: 命名约定
        type: table
        columns: [元素, 约定, 示例]
        instruction: 仅当与语言默认约定有差异时才需填写
      - id: critical-rules
        title: Critical Rules
        instruction: |
          仅列出 AI 可能违反的规则或与项目相关的特定要求。例如：
          - "生产代码不得使用 console.log —— 使用 logger"
          - "所有 API 响应必须使用 ApiResponse 包装类型"
          - "数据库查询必须采用仓储模式，禁止直接使用 ORM"

          避免罗列过于显而易见的规则（如 “使用 SOLID 原则”、“写干净代码” 等）
        repeatable: true
        template: "- **{{rule_name}}:** {{rule_description}}"
      - id: language-specifics
        title: Language-Specific Guidelines
        condition: Critical language-specific rules needed
        instruction: 仅在确实有助于防止 AI 犯错的关键规则时添加。大多数团队无需本节。
        sections:
          - id: language-rules
            title: "{{language_name}} Specifics"
            repeatable: true
            template: "- **{{rule_topic}}:** {{rule_detail}}"

  - id: test-strategy
    title: 测试策略与标准
    instruction: |
      与用户一起制定全面的测试策略：

      1. 使用“技术栈”中的测试框架
      2. 确定 TDD 或先开发后测试的方式
      3. 约定测试组织形式与命名
      4. 设定覆盖率目标
      5. 明确集成测试基础设施
      6. 规划测试数据与外部依赖

      说明：与开发智能体相关的基础信息可放在“编码规范”，本节用于 QA 智能体与团队的详细参考。
    elicit: true
    sections:
      - id: testing-philosophy
        title: 测试理念
        template: |
          - **Approach:** {{test_approach}}
          - **Coverage Goals:** {{coverage_targets}}
          - **Test Pyramid:** {{test_distribution}}
      - id: test-types
        title: 测试类型与组织
        sections:
          - id: unit-tests
            title: 单元测试
            template: |
              - **Framework:** {{unit_test_framework}} {{version}}
              - **File Convention:** {{unit_test_naming}}
              - **Location:** {{unit_test_location}}
              - **Mocking Library:** {{mocking_library}}
              - **Coverage Requirement:** {{unit_coverage}}

              **对 AI 智能体的要求：**
              - 为所有公共方法编写测试
              - 覆盖边界条件与错误场景
              - 遵循 AAA 模式（Arrange/准备，Act/执行，Assert/断言）
              - 对所有外部依赖进行 Mock
          - id: integration-tests
            title: 集成测试
            template: |
              - **Scope:** {{integration_scope}}
              - **Location:** {{integration_test_location}}
              - **Test Infrastructure:**
                - **{{dependency_name}}:** {{test_approach}} ({{test_tool}})
            examples:
              - "**数据库：** 单元测试使用内存 H2，集成测试使用 Testcontainers PostgreSQL"
              - "**消息队列：** 测试使用嵌入式 Kafka"
              - "**外部 API：** 使用 WireMock 进行桩替身（stubbing）"
          - id: e2e-tests
            title: 端到端测试
            template: |
              - **Framework:** {{e2e_framework}} {{version}}
              - **Scope:** {{e2e_scope}}
              - **Environment:** {{e2e_environment}}
              - **Test Data:** {{e2e_data_strategy}}
      - id: test-data-management
        title: 测试数据管理
        template: |
          - **Strategy:** {{test_data_approach}}
          - **Fixtures:** {{fixture_location}}
          - **Factories:** {{factory_pattern}}
          - **Cleanup:** {{cleanup_strategy}}
      - id: continuous-testing
        title: 持续测试
        template: |
          - **CI Integration:** {{ci_test_stages}}
          - **Performance Tests:** {{perf_test_approach}}
          - **Security Tests:** {{security_test_approach}}

  - id: security
    title: 安全
    instruction: |
      定义对 AI 与人类开发者都强制适用的安全要求：

      1. 聚焦于与实现相关的具体规则
      2. 参考“技术栈”中的安全工具
      3. 为常见场景定义清晰的模式
      4. 这些规则将直接影响代码生成
      5. 与用户合作，确保完整且不过度冗余
    elicit: true
    sections:
      - id: input-validation
        title: 输入校验
        template: |
          - **Validation Library:** {{validation_library}}
          - **Validation Location:** {{where_to_validate}}
          - **Required Rules:**
            - All external inputs MUST be validated
            - Validation at API boundary before processing
            - Whitelist approach preferred over blacklist
      - id: auth-authorization
        title: 认证与授权
        template: |
          - **Auth Method:** {{auth_implementation}}
          - **Session Management:** {{session_approach}}
          - **Required Patterns:**
            - {{auth_pattern_1}}
            - {{auth_pattern_2}}
      - id: secrets-management
        title: 密钥管理
        template: |
          - **Development:** {{dev_secrets_approach}}
          - **Production:** {{prod_secrets_service}}
          - **Code Requirements:**
            - NEVER hardcode secrets
            - Access via configuration service only
            - No secrets in logs or error messages
      - id: api-security
        title: API 安全
        template: |
          - **Rate Limiting:** {{rate_limit_implementation}}
          - **CORS Policy:** {{cors_configuration}}
          - **Security Headers:** {{required_headers}}
          - **HTTPS Enforcement:** {{https_approach}}
      - id: data-protection
        title: 数据保护
        template: |
          - **Encryption at Rest:** {{encryption_at_rest}}
          - **Encryption in Transit:** {{encryption_in_transit}}
          - **PII Handling:** {{pii_rules}}
          - **Logging Restrictions:** {{what_not_to_log}}
      - id: dependency-security
        title: 依赖安全
        template: |
          - **Scanning Tool:** {{dependency_scanner}}
          - **Update Policy:** {{update_frequency}}
          - **Approval Process:** {{new_dep_process}}
      - id: security-testing
        title: 安全测试
        template: |
          - **SAST Tool:** {{static_analysis}}
          - **DAST Tool:** {{dynamic_analysis}}
          - **Penetration Testing:** {{pentest_schedule}}

  - id: checklist-results
    title: 清单结果报告
    instruction: 在运行清单前，先提供导出完整架构文档的选项。用户确认后，执行 architect-checklist 并在此填充结果。

  - id: next-steps
    title: 后续步骤
    instruction: |
      完成本架构后：

      1. 若项目包含 UI 组件：
      - 使用“前端架构模式”
      - 将本文档作为输入

      2. 对所有项目：
      - 与产品负责人进行评审
      - 由开发智能体开始故事实现
      - 由 DevOps 智能体搭建基础设施

      3. 如有需要，为后续智能体准备具体的提示词
    sections:
      - id: architect-prompt
        title: 架构师提示
        condition: Project has UI components
        instruction: |
          编写一段简短提示词交付给架构师以创建前端架构，内容应包含：
          - 对本架构文档的引用
          - 来自 PRD 的关键 UI 需求
          - 本文确定的前端相关决策
          - 对详细前端架构的请求
