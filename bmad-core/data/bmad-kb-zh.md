<!-- Powered by BMAD™ Core -->

# BMAD™ 知识库

## 概述

BMAD-METHOD™ (突破性的敏捷AI驱动开发方法) 是一个将AI智能体与敏捷开发方法论相结合的框架。v4 版本引入了模块化架构，改进了依赖管理、捆绑包优化，并支持 Web 和 IDE 两种环境。

### 核心特性

- **模块化智能体系统**: 为每个敏捷角色提供专门的 AI 智能体
- **构建系统**: 自动化的依赖解析和优化
- **双环境支持**: 针对 Web UI 和 IDE 进行了优化
- **可复用资源**: 可移植的模板、任务和检查清单
- **斜杠命令集成**: 快速切换智能体和控制

### 何时使用 BMad

- **新项目 (绿地开发)**: 完整的端到端开发
- **现有项目 (褐地开发)**: 功能添加和增强
- **团队协作**: 多个角色协同工作
- **质量保证**: 结构化的测试和验证
- **文档编写**: 专业的 PRD、架构文档、用户故事

## BMad 如何工作

### 核心方法

BMad 将你转变为 "Vibe CEO" - 通过结构化的工作流来指导一支专业的 AI 智能体团队。工作方式如下：

1. **你来指导，AI 来执行**: 你提供愿景和决策；智能体处理实现细节
2. **专业化智能体**: 每个智能体都精通一个角色 (PM, Developer, Architect 等)
3. **结构化工作流**: 经验证的模式引导你从想法到部署代码
4. **清晰的交接**: 全新的上下文窗口确保智能体保持专注和高效

### 两阶段方法

#### 第一阶段：规划 (Web UI - 成本效益高)

- 利用大上下文窗口 (如 Gemini 的 100 万个 token)
- 生成全面的文档 (PRD, 架构)
- 利用多个智能体进行头脑风暴
- 一次性创建，贯穿整个开发过程

#### 第二阶段：开发 (IDE - 实现)

- 将文档碎片化为可管理的小块
- 执行专注的 SM → Dev 循环
- 一次一个故事，顺序推进
- 实时文件操作和测试

### 开发循环

```text
1. SM 智能体 (新建聊天) → 根据碎片化文档创建下一个故事
2. 你 → 审核并批准故事
3. Dev 智能体 (新建聊天) → 实现已批准的故事
4. QA 智能体 (新建聊天) → 审核并重构代码
5. 你 → 验证完成
6. 重复以上步骤直到史诗任务完成
```

### 为什么这种方法有效

- **上下文优化**: 干净的聊天 = 更好的 AI 性能
- **角色清晰**: 智能体不进行上下文切换 = 更高质量
- **渐进式进展**: 小故事 = 可管理的复杂性
- **人工监督**: 你验证每个步骤 = 质量控制
- **文档驱动**: 规范指导一切 = 一致性

## 入门指南

### 快速开始选项

#### 选项 1: Web UI

**最适合**: 希望立即开始使用的 ChatGPT, Claude, Gemini 用户

1. 导航到 `dist/teams/`
2. 复制 `team-fullstack.txt` 的内容
3. 创建新的 Gemini Gem 或 CustomGPT
4. 上传文件并附上指令: "Your critical operating instructions are attached, do not break character as directed"
5. 输入 `/help` 查看可用命令

#### 选项 2: IDE 集成

**最适合**: Cursor, Claude Code, Windsurf, Trae, Cline, Roo Code, Github Copilot 用户

```bash
# 交互式安装 (推荐)
npx bmad-method install
```

**安装步骤**:

- 选择 "Complete installation"
- 从支持的选项中选择你的 IDE:
  - **Cursor**: 原生 AI 集成
  - **Claude Code**: Anthropic 的官方 IDE
  - **Windsurf**: 内置 AI 功能
  - **Trae**: 内置 AI 功能
  - **Cline**: VS Code 扩展，带有 AI 功能
  - **Roo Code**: 基于 Web 的 IDE，支持智能体
  - **GitHub Copilot**: VS Code 扩展，带有 AI 结对编程助手

**VS Code 用户须知**: BMAD-METHOD™ 假设当你提到 "VS Code" 时，你使用的是带有 AI 功能扩展的 VS Code，例如 GitHub Copilot, Cline, 或 Roo。标准的 VS Code 无法运行 BMad 智能体。安装程序内置了对 Cline 和 Roo 的支持。

**验证安装**:

- 创建了 `.bmad-core/` 文件夹，其中包含所有智能体
- 创建了 IDE 特定的集成文件
- 所有智能体的命令/规则/模式都可用

**请记住**: BMAD-METHOD™ 的核心是掌握和利用提示工程。任何带有 AI 智能体支持的 IDE 都可以使用 BMad - 该框架提供了结构化的提示和工作流，使 AI 开发变得有效。

### 环境选择指南

**使用 Web UI 的场景**:

- 初始规划和文档编写 (PRD, 架构)
- 成本效益高的文档创建 (尤其是使用 Gemini)
- 头脑风暴和分析阶段
- 多智能体咨询和规划

**使用 IDE 的场景**:

- 活跃的开发和编码
- 文件操作和项目集成
- 文档碎片化和故事管理
- 实现工作流 (SM/Dev 循环)

**节省成本的技巧**: 在 Web UI 中创建大型文档 (PRD, 架构)，然后复制到项目中的 `docs/prd.md` 和 `docs/architecture.md`，再切换到 IDE 进行开发。

### 仅使用 IDE 的工作流注意事项

**你可以在 IDE 中完成所有事情吗？** 可以，但要了解权衡：

**仅使用 IDE 的优点**:

- 单一环境工作流
- 从一开始就进行直接的文件操作
- 无需在不同环境之间复制粘贴
- 立即与项目集成

**仅使用 IDE 的缺点**:

- 创建大型文档的成本更高
- 上下文窗口较小 (因 IDE/模型而异)
- 在规划阶段可能会达到限制
- 对于头脑风暴来说成本效益较低

**在 IDE 中使用 Web 智能体**:

- **不推荐**: Web 智能体 (PM, Architect) 具有丰富的依赖关系，专为大上下文设计
- **为什么重要**: Dev 智能体保持精简，以最大化编码上下文
- **原则**: "Dev 智能体编码，规划智能体规划" - 混合使用会破坏这种优化

**关于 bmad-master 和 bmad-orchestrator**:

- **bmad-master**: 可以执行任何任务而无需切换智能体，但是...
- **规划时仍使用专门的智能体**: PM, Architect, 和 UX Expert 具有经过调整的人格，可以产生更好的结果
- **为什么专业化很重要**: 每个智能体的人格和关注点都能创造出更高质量的输出
- **如果使用 bmad-master/orchestrator**: 在规划阶段可以，但是...

**开发阶段的关键规则**:

- **始终使用 SM 智能体来创建故事** - 永远不要使用 bmad-master 或 bmad-orchestrator
- **始终使用 Dev 智能体来实现** - 永远不要使用 bmad-master 或 bmad-orchestrator
- **为什么这很重要**: SM 和 Dev 智能体专门为开发工作流进行了优化
- **没有例外**: 即使你用 bmad-master 做其他所有事情，在实现时也要切换到 SM → Dev

**仅使用 IDE 的最佳实践**:

1. 使用 PM/Architect/UX 智能体进行规划 (比 bmad-master 更好)
2. 直接在项目中创建文档
3. 创建后立即进行碎片化
4. **必须切换到 SM 智能体** 来创建故事
5. **必须切换到 Dev 智能体** 来实现
6. 将规划和编码保持在单独的聊天会话中

## 核心配置 (core-config.yaml)

**V4 中的新功能**: `bmad-core/core-config.yaml` 文件是一项关键创新，它使 BMad 能够无缝地与任何项目结构配合工作，提供最大的灵活性和向后兼容性。

### 什么是 core-config.yaml?

这个配置文件充当 BMad 智能体的地图，明确告诉它们在哪里可以找到你的项目文档以及它们是如何结构化的。它实现了：

- **版本灵活性**: 可以处理 V3, V4 或自定义的文档结构
- **自定义位置**: 定义文档和碎片的位置
- **开发者上下文**: 指定 Dev 智能体应始终加载的文件
- **调试支持**: 内置日志记录用于故障排除

### 关键配置区域

#### PRD 配置

- **prdVersion**: 告诉智能体 PRD 遵循 v3 还是 v4 约定
- **prdSharded**: 史诗任务是嵌入的 (false) 还是在单独的文件中 (true)
- **prdShardedLocation**: 在哪里可以找到碎片化的史诗任务文件
- **epicFilePattern**: 史诗任务文件名的模式 (例如, `epic-{n}*.md`)

#### 架构配置

- **architectureVersion**: v3 (整体式) 或 v4 (碎片化)
- **architectureSharded**: 架构是否拆分为组件
- **architectureShardedLocation**: 碎片化架构文件的位置

#### 开发者文件

- **devLoadAlwaysFiles**: Dev 智能体为每个任务加载的文件列表
- **devDebugLog**: Dev 智能体记录重复失败的地方
- **agentCoreDump**: 导出聊天对话的位置

### 为什么这很重要

1. **无需强制迁移**: 保留你现有的文档结构
2. **逐步采用**: 从 V3 开始，按自己的节奏迁移到 V4
3. **自定义工作流**: 配置 BMad 以匹配你的团队流程
4. **智能智能体**: 智能体会自动适应你的配置

### 常见配置

**遗留 V3 项目**:

```yaml
prdVersion: v3
prdSharded: false
architectureVersion: v3
architectureSharded: false
```

**V4 优化项目**:

```yaml
prdVersion: v4
prdSharded: true
prdShardedLocation: docs/prd
architectureVersion: v4
architectureSharded: true
architectureShardedLocation: docs/architecture
```

## 核心理念

### Vibe CEO'ing

你是 "Vibe CEO" - 像拥有无限资源和单一愿景的 CEO 一样思考。你的 AI 智能体是你的高能团队，你的角色是：

- **指导**: 提供清晰的指令和目标
- **优化**: 迭代输出以达到质量要求
- **监督**: 在所有智能体之间保持战略一致性

### 核心原则

1. **最大化 AI 利用率**: 推动 AI 提供更多。挑战输出并迭代。
2. **质量控制**: 你是质量的最终仲裁者。审查所有输出。
3. **战略监督**: 保持高层愿景并确保一致。
4. **迭代优化**: 期望重新审视步骤。这不是线性过程。
5. **清晰的指令**: 精确的请求带来更好的输出。
6. **文档是关键**: 好的输入 (简报, PRD) 带来好的输出。
7. **小规模快速启动**: 测试概念，然后扩展。
8. **拥抱混乱**: 适应并克服挑战。

### 关键工作流原则

1. **智能体专业化**: 每个智能体都有特定的专业知识和职责
2. **干净的交接**: 在切换智能体时始终重新开始
3. **状态跟踪**: 维护故事状态 (草稿 → 已批准 → 进行中 → 完成)
4. **迭代开发**: 完成一个故事后再开始下一个
5. **文档优先**: 始终从坚实的 PRD 和架构开始

## 智能体系统

### 核心开发团队

| 智能体      | 角色           | 主要功能                 | 使用场景               |
| ----------- | -------------- | ------------------------ | ---------------------- |
| `analyst`   | 业务分析师     | 市场调研, 需求收集       | 项目规划, 竞争对手分析 |
| `pm`        | 产品经理       | PRD 创建, 功能优先级排序 | 战略规划, 路线图       |
| `architect` | 解决方案架构师 | 系统设计, 技术架构       | 复杂系统, 可扩展性规划 |
| `dev`       | 开发人员       | 代码实现, 调试           | 所有开发任务           |
| `qa`        | QA 专家        | 测试规划, 质量保证       | 测试策略, bug 验证     |
| `ux-expert` | UX 设计师      | UI/UX 设计, 原型         | 用户体验, 界面设计     |
| `po`        | 产品负责人     | 待办事项管理, 故事验证   | 故事优化, 验收标准     |
| `sm`        | Scrum Master   | 冲刺规划, 故事创建       | 项目管理, 工作流       |

### 元智能体

| 智能体              | 角色       | 主要功能                 | 使用场景           |
| ------------------- | ---------- | ------------------------ | ------------------ |
| `bmad-orchestrator` | 团队协调员 | 多智能体工作流, 角色切换 | 复杂的多角色任务   |
| `bmad-master`       | 通用专家   | 无需切换即可执行所有功能 | 单一会话的综合工作 |

### 智能体交互命令

#### IDE 特定语法

**按 IDE 加载智能体**:

- **Claude Code**: `/agent-name` (例如, `/bmad-master`)
- **Cursor**: `@agent-name` (例如, `@bmad-master`)
- **Windsurf**: `/agent-name` (例如, `/bmad-master`)
- **Trae**: `@agent-name` (例如, `@bmad-master`)
- **Roo Code**: 从模式选择器中选择模式 (例如, `bmad-master`)
- **GitHub Copilot**: 打开聊天视图 (`⌃⌘I` 在 Mac 上, `Ctrl+Alt+I` 在 Windows/Linux 上) 并从聊天模式选择器中选择 **Agent**。

**聊天管理指南**:

- **Claude Code, Cursor, Windsurf, Trae**: 在切换智能体时启动新聊天
- **Roo Code**: 在同一对话中切换模式

**常用任务命令**:

- `*help` - 显示可用命令
- `*status` - 显示当前上下文/进度
- `*exit` - 退出智能体模式
- `*shard-doc docs/prd.md prd` - 将 PRD 碎片化为可管理的小块
- `*shard-doc docs/architecture.md architecture` - 将架构文档碎片化
- `*create` - 运行 create-next-story 任务 (SM 智能体)

**在 Web UI 中**:

```text
/pm create-doc prd
/architect review system design
/dev implement story 1.2
/help - 显示可用命令
/switch agent-name - 更改活动智能体 (如果 orchestrator 可用)
```

## 团队配置

### 预构建团队

#### Team All

- **包含**: 所有 10 个智能体 + orchestrator
- **使用场景**: 需要所有角色的完整项目
- **包**: `team-all.txt`

#### Team Fullstack

- **包含**: PM, Architect, Developer, QA, UX Expert
- **使用场景**: 端到端的 Web/移动开发
- **包**: `team-fullstack.txt`

#### Team No-UI

- **包含**: PM, Architect, Developer, QA (无 UX Expert)
- **使用场景**: 后端服务, APIs, 系统开发
- **包**: `team-no-ui.txt`

## 核心架构

### 系统概述

BMAD-METHOD™ 围绕着以 `bmad-core` 目录为中心的模块化架构构建，该目录作为整个系统的“大脑”。这种设计使该框架能够在 IDE 环境 (如 Cursor, VS Code) 和基于 Web 的 AI 界面 (如 ChatGPT, Gemini) 中有效运行。

### 关键架构组件

#### 1. 智能体 (`bmad-core/agents/`)

- **目的**: 每个 Markdown 文件都为特定的敏捷角色 (PM, Dev, Architect 等) 定义一个专门的 AI 智能体
- **结构**: 包含 YAML 标头，指定智能体的人格、能力和依赖关系
- **依赖关系**: 智能体可以使用的任务、模板、检查清单和数据文件列表
- **启动指令**: 可以加载项目特定的文档以获得即时上下文

#### 2. 智能体团队 (`bmad-core/agent-teams/`)

- **目的**: 定义捆绑在一起用于特定目的的智能体集合
- **示例**: `team-all.yaml` (综合包), `team-fullstack.yaml` (全栈开发)
- **用途**: 为 Web UI 环境创建预打包的上下文

#### 3. 工作流 (`bmad-core/workflows/`)

- **目的**: YAML 文件定义特定项目类型的预定步骤序列
- **类型**: 用于 UI、服务和全栈开发的绿地和褐地项目
- **结构**: 定义智能体交互、创建的工件和转换条件

#### 4. 可复用资源

- **模板** (`bmad-core/templates/`): 用于 PRD、架构规范、用户故事的 Markdown 模板
- **任务** (`bmad-core/tasks/`): 用于特定可重复操作的指令，例如 "shard-doc" 或 "create-next-story"
- **检查清单** (`bmad-core/checklists/`): 用于验证和审查的质量保证检查清单
- **数据** (`bmad-core/data/`): 核心知识库和技术偏好

### 双环境架构

#### IDE 环境

- 用户直接与智能体 Markdown 文件交互
- 智能体可以动态访问所有依赖关系
- 支持实时文件操作和项目集成
- 针对开发工作流执行进行了优化

#### Web UI 环境

- 使用 `dist/teams` 中的预构建包，这些包是为上传到 Web 接口而准备的独立 1 个文件，包含所有智能体及其资产和一个协调智能体
- `dist/agents/` 中的单个文本文件包含所有智能体依赖关系 - 除非你想创建一个仅包含单个智能体而不是团队的 Web 智能体，否则这些是不必要的

### 模板处理系统

BMad 采用了一个复杂的模板系统，包含三个关键组件：

1. **模板格式** (`utils/bmad-doc-template.md`): 定义用于 YAML 模板中的变量替换和 AI 处理指令的标记语言
2. **文档创建** (`tasks/create-doc.md`): 编排模板选择和用户交互，将 YAML 规范转换为最终的 Markdown 输出
3. **高级引导** (`tasks/advanced-elicitation.md`): 通过结构化头脑风暴提供交互式优化

### 技术偏好集成

`technical-preferences.md` 文件作为持久的技术档案，可以：

- 确保跨所有智能体和项目的一致性
- 消除重复的技术规范
- 提供与用户偏好一致的个性化建议
- 随着经验教训的积累而发展

### 构建和交付流程

`web-builder.js` 工具通过以下方式创建 Web 就绪的包：

1. 读取智能体或团队定义文件
2. 递归解析所有依赖关系
3. 将内容连接成带有清晰分隔符的单个文本文件
4. 输出可用于 Web AI 接口的即用型包

这种架构实现了跨环境的无缝操作，同时保持了使 BMad 强大的丰富、互连的智能体生态系统。

## 完整的开发工作流

### 规划阶段 (推荐使用 Web UI - 尤其是 Gemini!)

**利用 Gemini 的大上下文实现成本效益：**

**对于褐地项目 - 从这里开始！**:

1. **将整个项目上传到 Gemini Web** (GitHub URL, 文件, 或 zip)
2. **记录现有系统**: `/analyst` → `*document-project`
3. **从整个代码库分析创建全面的文档**

**对于所有项目**:

1. **可选分析**: `/analyst` - 市场调研, 竞争对手分析
2. **项目简报**: 创建基础文档 (分析师或用户)
3. **PRD 创建**: `/pm create-doc prd` - 全面的产品需求
4. **架构设计**: `/architect create-doc architecture` - 技术基础
5. **验证与对齐**: `/po` 运行主检查清单以确保文档一致性
6. **文档准备**: 将最终文档复制到项目中作为 `docs/prd.md` 和 `docs/architecture.md`

#### 示例规划提示

**用于 PRD 创建**:

```text
"我想构建一个 [类型] 应用程序，其 [核心目的]。
帮我头脑风暴功能并创建一份全面的 PRD。"
```

**用于架构设计**:

```text
"基于这份 PRD，设计一个可扩展的技术架构
能够处理 [特定需求]。"
```

### 关键过渡：Web UI 到 IDE

**规划完成后，你必须切换到 IDE 进行开发：**

- **为什么**: 开发工作流需要文件操作、实时项目集成和文档碎片化
- **成本效益**: Web UI 在创建大型文档方面更具成本效益；IDE 针对开发任务进行了优化
- **必需文件**: 确保项目中存在 `docs/prd.md` 和 `docs/architecture.md`

### IDE 开发工作流

**前提条件**: 规划文档必须存在于 `docs/` 文件夹中

1. **文档碎片化** (关键步骤):
   - 由 PM/Architect 创建的文档 (在 Web 或 IDE 中) 必须进行碎片化才能进行开发
   - 两种碎片化方法:
     a) **手动**: 将 `shard-doc` 任务 + 文档文件拖入聊天
     b) **智能体**: 询问 `@bmad-master` 或 `@po` 来碎片化文档
   - 将 `docs/prd.md` 碎片化 → `docs/prd/` 文件夹
   - 将 `docs/architecture.md` 碎片化 → `docs/architecture/` 文件夹
   - **警告**: 不要在 Web UI 中进行碎片化 - 复制许多小文件很痛苦！

2. **验证碎片化内容**:
   - `docs/prd/` 中至少有一个 `epic-n.md` 文件，其中的故事按开发顺序排列
   - 供 dev 智能体参考的源树文档和编码标准
   - 供 SM 智能体创建故事的碎片化文档

结果文件夹结构:

- `docs/prd/` - 分解的 PRD 部分
- `docs/architecture/` - 分解的架构部分
- `docs/stories/` - 生成的用户故事

1. **开发循环** (顺序进行，一次一个故事):

   **关键上下文管理**:
   - **上下文窗口很重要！** 始终使用全新、干净的上下文窗口
   - **模型选择很重要！** 为 SM 故事创建使用最强大的思维模型
   - **在 SM、Dev 和 QA 工作之间始终开始新的聊天**

   **步骤 1 - 故事创建**:
   - **新建干净的聊天** → 选择强大的模型 → `@sm` → `*create`
   - SM 执行 create-next-story 任务
   - 在 `docs/stories/` 中审核生成的故事
   - 将状态从 "草稿" 更新为 "已批准"

   **步骤 2 - 故事实现**:
   - **新建干净的聊天** → `@dev`
   - 智能体询问要实现哪个故事
   - 包含故事文件内容以节省 dev 智能体查找时间
   - Dev 遵循任务/子任务，标记完成情况
   - Dev 维护所有更改的文件列表
   - Dev 在所有测试通过后将故事标记为 "审查"

   **步骤 3 - 高级 QA 审查**:
   - **新建干净的聊天** → `@qa` → 执行 review-story 任务
   - QA 执行高级开发人员代码审查
   - QA 可以直接重构和改进代码
   - QA 将结果附加到故事的 QA 结果部分
   - 如果批准: 状态 → "完成"
   - 如果需要更改: 状态保持 "审查"，dev 有待处理项目

   **步骤 4 - 重复**: 继续 SM → Dev → QA 循环，直到所有史诗任务故事完成

**重要**: 一次只进行一个故事，按顺序工作，直到所有史诗任务故事完成。

### 状态跟踪工作流

故事会通过定义的状态进行：

- **草稿** → **已批准** → **进行中** → **完成**

每次状态更改都需要用户验证和批准才能继续。

### 工作流类型

#### 绿地开发

- 业务分析和市场调研
- 产品需求和功能定义
- 系统架构和设计
- 开发执行
- 测试和部署

#### 褐地增强 (现有项目)

**关键概念**: 褐地开发需要对现有项目进行全面的文档记录，以便 AI 智能体理解上下文、模式和约束。

**完整的褐地工作流选项**:

**选项 1: PRD优先 (推荐用于大型代码库/单体)**:

1. **将项目上传到 Gemini Web** (GitHub URL, 文件, 或 zip)
2. **首先创建 PRD**: `@pm` → `*create-doc brownfield-prd`
3. **聚焦文档**: `@analyst` → `*document-project`
   - 如果没有提供 PRD，分析师会询问重点
   - 选择 "单个文档" 格式用于 Web UI
   - 使用 PRD 来记录仅相关的区域
   - 创建一个全面的 Markdown 文件
   - 避免用未使用的代码填充文档

**选项 2: 文档优先 (适用于小型项目)**:

1. **将项目上传到 Gemini Web**
2. **记录所有内容**: `@analyst` → `*document-project`
3. **然后创建 PRD**: `@pm` → `*create-doc brownfield-prd`
   - 更加彻底，但可能会创建过多的文档

4. **需求收集**:
   - **褐地 PRD**: 使用 PM 智能体和 `brownfield-prd-tmpl`
   - **分析**: 现有系统、约束、集成点
   - **定义**: 增强范围、兼容性要求、风险评估
   - **创建**: 变更的史诗任务和故事结构

5. **架构规划**:
   - **褐地架构**: 使用 Architect 智能体和 `brownfield-architecture-tmpl`
   - **集成策略**: 新功能如何与现有系统集成
   - **迁移规划**: 逐步推出和向后兼容性
   - **风险缓解**: 解决潜在的破坏性变更

**褐地特定资源**:

**模板**:

- `brownfield-prd-tmpl.md`: 具有现有系统分析的全面增强规划
- `brownfield-architecture-tmpl.md`: 现有系统的集成导向架构

**任务**:

- `document-project`: 从现有代码库生成全面的文档
- `brownfield-create-epic`: 为聚焦增强创建单个史诗任务 (当完整的 PRD 过于复杂时)
- `brownfield-create-story`: 为小的、孤立的变更创建单个故事

**何时使用每种方法**:

**完整褐地工作流** (推荐用于):

- 重大功能添加
- 系统现代化
- 复杂集成
- 多个相关变更

**快速史诗任务/故事创建** (使用时机):

- 单一、聚焦的增强
- 孤立的错误修复
- 小功能添加
- 文档良好的现有系统

**成功的关键因素**:

1. **文档优先**: 如果文档过时/缺失，始终运行 `document-project`
2. **上下文很重要**: 为智能体提供对相关代码部分的访问权限
3. **集成重点**: 强调兼容性和非破坏性变更
4. **渐进式方法**: 计划逐步推出和测试

**详细指南**: 参见 `docs/working-in-the-brownfield.md`

## 文档创建最佳实践

### 框架集成所需的文件命名

- `docs/prd.md` - 产品需求文档
- `docs/architecture.md` - 系统架构文档

**为什么这些名称很重要**:

- 智能体在开发过程中会自动引用这些文件
- 碎片化任务期望这些特定的文件名
- 工作流自动化依赖于标准命名

### 成本效益的文档创建工作流

**推荐用于大型文档 (PRD, 架构):**

1. **使用 Web UI**: 在 Web 界面中创建文档以实现成本效益
2. **复制最终输出**: 将完整的 Markdown 保存到你的项目中
3. **标准名称**: 保存为 `docs/prd.md` 和 `docs/architecture.md`
4. **切换到 IDE**: 使用 IDE 智能体进行开发和小型文档

### 文档碎片化

具有二级标题 (`##`) 的模板可以自动碎片化：

**原始 PRD**:

```markdown
## 目标和背景上下文

## 需求

## 用户界面设计目标

## 成功指标
```

**碎片化后**:

- `docs/prd/goals-and-background-context.md`
- `docs/prd/requirements.md`
- `docs/prd/user-interface-design-goals.md`
- `docs/prd/success-metrics.md`

使用 `shard-doc` 任务或 `@kayvan/markdown-tree-parser` 工具进行自动碎片化。

## 使用模式和最佳实践

### 环境特定使用

**Web UI 最佳用于**:

- 初始规划和文档编写阶段
- 成本效益高的大型文档创建
- 智能体咨询和头脑风暴
- 使用协调器的多智能体工作流

**IDE 最佳用于**:

- 活跃的开发和实现
- 文件操作和项目集成
- 故事管理和开发周期
- 代码审查和调试

### 质量保证

- 为专门的任务使用适当的智能体
- 遵循敏捷仪式和审查流程
- 使用 PO 智能体维护文档一致性
- 使用检查清单和模板进行定期验证

### 性能优化

- 使用特定智能体而不是 `bmad-master` 来处理专注的任务
- 选择适当的团队规模以满足项目需求
- 利用技术偏好来保持一致性
- 定期进行上下文管理和缓存清除

## 成功技巧

- **使用 Gemini 进行宏观规划** - team-fullstack 包提供了协作的专业知识
- **使用 bmad-master 进行文档组织** - 碎片化创建可管理的块
- **严格遵循 SM → Dev 循环** - 这确保了系统的进展
- **保持对话专注** - 每个对话一个智能体，一个任务
- **审查一切** - 在标记完成之前始终审查和批准

## 为 BMAD-METHOD™ 做贡献

### 快速贡献指南

有关完整详情，请参见 `CONTRIBUTING.md`。要点：

**Fork 工作流**:

1. Fork 仓库
2. 创建功能分支
3. 向 `next` 分支 (默认) 或 `main` 分支提交 PR (仅用于关键修复)
4. 保持 PR 小巧: 200-400 行理想，800 行最大
5. 每个 PR 一个功能/修复

**PR 要求**:

- 清晰的描述 (最多 200 字)，包含 What/Why/How/Testing
- 使用传统提交 (feat:, fix:, docs:)
- 原子提交 - 每次提交一个逻辑变更
- 必须与指导原则保持一致

**核心原则** (来自 docs/GUIDING-PRINCIPLES.md):

- **Dev 智能体必须精简**: 最小化依赖关系，为代码节省上下文
- **自然语言优先**: 一切都在 Markdown 中，核心中没有代码
- **核心 vs 扩展包**: 核心用于普遍需求，包用于专业领域
- **设计哲学**: "Dev 智能体编码，规划智能体规划"

## 扩展包

### 什么是扩展包?

扩展包将 BMAD-METHOD™ 扩展到传统的软件开发之外，进入任何领域。它们提供专门的智能体团队、模板和工作流，同时保持核心框架的精简和专注于开发。

### 为什么使用扩展包?

1. **保持核心精简**: Dev 智能体为编码保持最大上下文
2. **领域专业知识**: 深度、专业的知识而不会使核心膨胀
3. **社区创新**: 任何人都可以创建和分享包
4. **模块化设计**: 只安装你需要的东西

### 可用的扩展包

**技术包**:

- **基础设施/DevOps**: 云架构师, SRE 专家, 安全专家
- **游戏开发**: 游戏设计师, 关卡设计师, 叙事作家
- **移动开发**: iOS/Android 专家, 移动 UX 专家
- **数据科学**: ML 工程师, 数据科学家, 可视化专家

**非技术包**:

- **商业战略**: 顾问, 金融分析师, 市场战略师
- **创意写作**: 情节架构师, 角色开发者, 世界构建者
- **健康与 wellness**: 健身教练, 营养师, 习惯工程师
- **教育**: 课程设计师, 评估专家
- **法律支持**: 合同分析师, 合规检查员

**特色包**:

- **扩展创建者**: 构建你自己的扩展包的工具
- **RPG 游戏大师**: 桌面游戏辅助
- **生活事件规划**: 婚礼策划师, 活动协调员
- **科学研究**: 文献审稿人, 方法论设计师

### 使用扩展包

1. **浏览可用包**: 检查 `expansion-packs/` 目录
2. **获取灵感**: 参见 `docs/expansion-packs.md` 获取详细的示例和想法
3. **通过 CLI 安装**:

   ```bash
   npx bmad-method install
   # 选择 "Install expansion pack" 选项
   ```

4. **在你的工作流中使用**: 安装的包与现有智能体无缝集成

### 创建自定义扩展包

使用 **expansion-creator** 包来构建你自己的扩展包:

1. **定义领域**: 你在捕捉什么专业知识?
2. **设计智能体**: 创建具有明确边界的专门角色
3. **构建资源**: 为你的领域创建任务、模板、检查清单
4. **测试和分享**: 使用真实用例进行验证，与社区分享

**关键原则**: 扩展包通过使专业知识可以通过 AI 智能体访问来实现专业知识的民主化。

## 获取帮助

- **命令**: 在任何环境中使用 `*/*help` 查看可用命令
- **智能体切换**: 使用 `*/*switch agent-name` 和 orchestrator 进行角色更改
- **文档**: 检查 `docs/` 文件夹以获取项目特定的上下文
- **社区**: Discord 和 GitHub 资源可用于支持
- **贡献**: 参见 `CONTRIBUTING.md` 获取完整指南
